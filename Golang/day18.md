## Day 18: Docker Compose ðŸŽ¼

Running individual containers with `docker run` is great, but real-world applications are often made up of multiple services that need to work together (like your API, a database, and a cache). **Docker Compose** is a tool for defining and running multi-container Docker applications. It allows you to use a single command to start, stop, and manage your entire application stack.

-----

### Managing Multi-container Applications

With Docker Compose, you use a YAML file, typically named `docker-compose.yml`, to configure all of your application's services. This file acts as the single source of truth for your entire application stack.

**Key Concepts:**

  * **Services:** A service is a single running container in your application. For example, you'll have a service for your Go API, a service for your PostgreSQL database, and a service for Redis. Each service is defined based on a Docker image.
  * **Networks:** Docker Compose automatically creates a dedicated network for your application. All services defined in the `docker-compose.yml` file are attached to this network, allowing them to discover and communicate with each other using their service names as hostnames.
  * **Volumes:** To persist data generated by containers (like your database files), you use volumes. Volumes are a mechanism for storing data on the host machine, outside the container's lifecycle, ensuring your data isn't lost when a container is removed or restarted.

-----

### Task 1 & 2: Write a `docker-compose.yml` file and use `docker-compose up`.

**Solution:**

Create a file named `docker-compose.yml` in the root of your project. This file will define our two services: `api` (our Go application) and `db` (our PostgreSQL database).

**`docker-compose.yml`:**

```yaml
# Specifies the version of the Docker Compose file format.
version: '3.8'

# 'services' is the main section where we define our containers.
services:
  # This is the service for our PostgreSQL database.
  db:
    # Use the official postgres image from Docker Hub.
    image: postgres:15-alpine
    # Always restart the container if it stops, unless it was manually stopped.
    restart: always
    # Environment variables needed to initialize the PostgreSQL database.
    environment:
      POSTGRES_USER: gorm
      POSTGRES_PASSWORD: gorm
      POSTGRES_DB: gorm
    # Map port 5432 on the host to port 5432 in the container.
    ports:
      - "5432:5432"
    # Define a volume to persist the database data.
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # This is the service for our Go Gin API.
  api:
    # Build the image from the Dockerfile in the current directory.
    build: .
    # Always restart the container if it stops.
    restart: always
    # Map port 8080 on the host to port 8080 in the container.
    ports:
      - "8080:8080"
    # Environment variables for our API.
    environment:
      DATABASE_DSN: "host=db user=gorm password=gorm dbname=gorm port=5432 sslmode=disable"
    # 'depends_on' tells Docker Compose to start the 'db' service before starting the 'api' service.
    depends_on:
      - db

# 'volumes' is a top-level section to declare named volumes.
volumes:
  postgres_data:
```

**To start your entire application stack:**

Navigate to your project's root directory in the terminal and run:

```sh
docker-compose up
```

To run it in the background (detached mode), use:

```sh
docker-compose up -d
```

To stop and remove all the containers, networks, and volumes defined in the file, run:

```sh
docker-compose down
```

-----

### Task 3: Configure networking between containers.

**Solution:**

The networking is actually configured implicitly in the `docker-compose.yml` file. When you run `docker-compose up`, Docker Compose does the following:

1.  Creates a default network for your project (e.g., `myproject_default`).
2.  Attaches both the `api` and `db` services to this network.

This allows containers to communicate with each other using their **service names** as hostnames. Notice the `DATABASE_DSN` for our `api` service:

```yaml
environment:
  DATABASE_DSN: "host=db user=gorm password=gorm dbname=gorm port=5432 sslmode=disable"
```

Here, `host=db` works because Docker's internal DNS will resolve the hostname `db` to the IP address of the `db` container on the shared network. You no longer need to use `localhost` or `host.docker.internal`.

-----

### Task 4: Add a new service (Redis cache).

**Solution:**

Adding a new service is as simple as adding another entry under the `services` key. Let's add a Redis service.

**`docker-compose.yml` (Updated):**

```yaml
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    restart: always
    environment:
      # ... (same as before)
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  # New service for Redis
  cache:
    # Use the official redis image with the Alpine tag for a smaller size.
    image: redis:7-alpine
    restart: always
    # Expose Redis's default port 6379 to the host.
    ports:
      - "6379:6379"

  api:
    build: .
    restart: always
    ports:
      - "8080:8080"
    environment:
      DATABASE_DSN: "host=db user=gorm password=gorm dbname=gorm port=5432 sslmode=disable"
      # Add the Redis address for our Go app to use.
      REDIS_ADDR: "cache:6379"
    # Our API now depends on both the database and the cache.
    depends_on:
      - db
      - cache

volumes:
  postgres_data:
```

Now, when you run `docker-compose up -d`, it will start three containers: your API, the PostgreSQL database, and the Redis cache. Your Go application can connect to Redis using the hostname `cache`.

-----

### Task 5: Learn how to use a `.env` file with Docker Compose.

**Solution:**

Hardcoding credentials like database passwords in your `docker-compose.yml` file is bad practice, especially if you commit it to version control. Docker Compose can automatically read a file named `.env` from the same directory and substitute variables from it into your `docker-compose.yml`.

1.  **Create a `.env` file:**
    In your project root, create a file named `.env`. **Remember to add `.env` to your `.gitignore` file\!**

    **`.env`:**

    ```
    # PostgreSQL Credentials
    POSTGRES_USER=gorm
    POSTGRES_PASSWORD=supersecretpassword
    POSTGRES_DB=gorm

    # API Port
    API_PORT=8080
    ```

2.  **Update your `docker-compose.yml` file:**
    Now, replace the hardcoded values with `${VARIABLE_NAME}` syntax.

    **`docker-compose.yml` (Updated with variables):**

    ```yaml
    version: '3.8'

    services:
      db:
        image: postgres:15-alpine
        restart: always
        environment:
          # Use variables from the .env file
          POSTGRES_USER: ${POSTGRES_USER}
          POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
          POSTGRES_DB: ${POSTGRES_DB}
        ports:
          - "5432:5432"
        volumes:
          - postgres_data:/var/lib/postgresql/data

      api:
        build: .
        restart: always
        ports:
          # Use a variable for the port mapping
          - "${API_PORT}:8080"
        environment:
          # Construct the DSN using variables
          DATABASE_DSN: "host=db user=${POSTGRES_USER} password=${POSTGRES_PASSWORD} dbname=${POSTGRES_DB} port=5432 sslmode=disable"
        depends_on:
          - db

    volumes:
      postgres_data:
    ```

Now, your `docker-compose.yml` is clean of secrets. You can share it safely, and each developer can have their own `.env` file with their local configuration. This is the standard, secure way to manage configuration in Docker Compose.